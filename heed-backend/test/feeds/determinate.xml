<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by Site-Server v6.0.0-dee94aea20be5e90d139b52d53bd7a6bfbfa0803-1 (http://www.squarespace.com) on Fri, 16 Sep 2022 15:21:13 GMT
--><rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://www.rssboard.org/media-rss" version="2.0"><channel><title>Blog - Determinate Systems</title><link>https://determinate.systems/posts/</link><lastBuildDate>Fri, 16 Sep 2022 15:19:29 +0000</lastBuildDate><language>en-US</language><generator>Site-Server v6.0.0-dee94aea20be5e90d139b52d53bd7a6bfbfa0803-1 (http://www.squarespace.com)</generator><description><![CDATA[]]></description><item><title>Building a highly optimized home environment with Nix</title><dc:creator>Luc Perkins</dc:creator><pubDate>Thu, 15 Sep 2022 14:00:00 +0000</pubDate><link>https://determinate.systems/posts/nix-home-env</link><guid isPermaLink="false">614cc40992cfe92efbb11fd4:615dfb3b1995b01cb9b11d90:6321e4d53fcffb6d26a6295c</guid><description><![CDATA[How I used Home Manager and a personal project called Nome to declutter and 
optimize my home environment using Nix]]></description><content:encoded><![CDATA[<p class="">A few weeks ago, fresh off of a minor victory in my local dev setup, I <a href="https://twitter.com/lucperkins/status/1555138195507105794">tweeted</a> this on a whim:</p>


















  

    

      <figure data-test="image-block-v2-outer-wrapper" class="
            sqs-block-image-figure
            image-block-outer-wrapper
            image-block-v2
            design-layout-stack
            combination-animation-site-default
            individual-animation-site-default
            individual-text-animation-site-default
            image-position-left
            
          " data-scrolled
      >

        
          
            
            
              
              <img class="sqs-image-min-height" data-image="https://images.squarespace-cdn.com/content/v1/614cc40992cfe92efbb11fd4/fb9dc8ce-1763-43ed-9443-da0fff142f11/Screen+Shot+2022-09-15+at+1.01.18+PM.jpg" data-image-dimensions="979x578" data-image-focal-point="0.5,0.5" alt="" loading="lazy" src="https://images.squarespace-cdn.com/content/v1/614cc40992cfe92efbb11fd4/fb9dc8ce-1763-43ed-9443-da0fff142f11/Screen+Shot+2022-09-15+at+1.01.18+PM.jpg?format=1000w"/>
              
            
          
            
          

        

        

      </figure>

    

  


<p class="">The reaction—120+ likes and 20+ retweets—was modest by broader Twitter standards but pretty strong for a rather vague tweet about <a href="https://nixos.org">Nix</a>. Today, I’d like to follow up on this tweet and show how I’ve used Nix to streamline my laptop environment in ways that have saved me time and made me substantially more productive across programming languages and platforms—and even jobs.</p><h3>How I used to do things</h3><p class="">Once upon a time, I managed my home environment, across several laptops and one desktop, the way that many devs do nowadays: I maintained a series dotfiles (for Vim, tmux, and others) that I updated now and then as needs changed. For executables, I used <code>brew install</code> whenever the need arose (I’m a macOS user almost exclusively).</p><p class="">Whenever I needed to change machines—new work laptop, new present to myself—I eagerly looked forward to building an environment I liked from scratch and in an ad-hoc way, usually with the help of my <code>dotfiles</code> Git repo and some kludgy shell scripts. This approach always more or less “worked” but it was always heavy on time and cognitive effort. The words “reproducible” and “declarative” weren’t yet on my radar, at least in this domain, but my longing for them certainly was. And then a piercing ray of light came into my life.</p><h3>Enter Home Manager</h3><p class="">When I first came upon Nix eight years ago, I was intrigued but it seemed like something for hardcore Linux folks and hardly something that could revolutionize my daily practices. That all changed when I discovered <a href="https://github.com/nix-community/home-manager" target="_blank">Home Manager</a> and began using it devoutly. Home Manager is a Nix-based tool for managing home environments in a declarative, reproducible way. It enabled me to toss out the tangled mess of dotfiles and shell scripts I previously relied upon in favor of one repo—and not a terribly complex one at that—where I could declare my entire environment with due precision: installed executables, Vim, tmux, and Visual Studio Code configuration, and much more. You can see my now-defunct Home Manager config <a href="https://github.com/lucperkins/nix-home-manager-config/">here</a>.</p><p class="">Home Manager provided me with a qualitatively better way to do things. I liked it so much that I wrote about my journey from <a href="https://lucperkins.dev/blog/home-manager/" target="_blank">Homebrew to Home Manager</a> on my personal blog. I wouldn’t dream of going back to my pre-Home-Manager life. But as you’ll see, Home Manager was not the end of the story for me.</p><h3>From Home Manager to Nome</h3><p class="">After a few years as a happy Home Manager user, I decided to get more ambitious and turn what I’ve learned about Nix and home environments into a concrete project. So I created a project called <a href="https://github.com/the-nix-way/nome">Nome</a>, which stands for <strong>N</strong>ix H<strong>ome</strong> (I was also born in Alaska and have fond memories of one of my first books, the <a href="https://www.goodreads.com/book/show/215480.The_Gnome_From_Nome">Gnome from Nome</a>). Nome is a highly customized Nix <a href="https://nixos.wiki/wiki/Flakes">flake</a> that provides <em>everything</em> that I need for my home environment.</p><p class="">Home Manager is the foundation stone of Nome. I use it to configure Vim, <a href="https://starship.rs">Starship</a>, VS Code, and the rest. But I’ve since gone beyond Home Manager because my needs have changed. Nowadays, I strive to make a clean separation between two things:</p><ol data-rte-list="default"><li><p class="">My <strong>global</strong> setup, meaning executables and configuration that I truly need to have available everywhere in my environment.</p></li><li><p class=""><strong>Project-level</strong> setups, where the environment is highly specific and</p></li></ol><p class="">I now use Home Manager only for my <a href="https://github.com/the-nix-way/nome/tree/main/home">global setup</a>. When it comes to specific projects, I get as granular as possible. Back in the day, I’d kick off a new project with <code>touch Makefile</code> and start defining commands like <code>build</code>, <code>clean</code>, and <code>dev</code>. But now I have a single command for starting new project, <a href="https://github.com/the-nix-way/nome/blob/main/home/bin.nix#L39-L41">proj</a>, which is an alias for this:</p>


<pre class="source-code">nix flake init --template github:the-nix-way/nome</pre><p class="">This initializes a Nix flake <a href="https://github.com/NixOS/templates" target="_blank">template</a> that provides a least-common-denominator dev environment consisting of a few toolchains that I use frequently:</p><ul data-rte-list="default"><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L17">Go</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L25-L39">Rust</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L6-L15">Elixir</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L4">DevOps</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L19">Kubernetes</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L21">Node.js</a></p></li><li><p class=""><a href="https://github.com/the-nix-way/nome/blob/main/lib/toolchains/default.nix#L23">Protocol Buffers</a></p></li></ul><p class="">Each of these toolchains is just a collection of executables. The Rust toolchain, for example, includes a standard Rust toolchain plus <a href="https://github.com/killercup/cargo-edit">cargo edit</a>, <a href="https://github.com/cross-rs/cross">cross</a>, <a href="https://rust-analyzer.github.io">rust-analyzer</a>, and other utilities that I’m likely to need.</p><p class="">Here’s the block of the <code>flake.nix</code> that defines a project’s shell environment:</p>


<pre class="source-code">nome.lib.mkEnv {
  toolchains = with nome.lib.toolchains;
    devops ++ elixir ++ go ++ kubernetes ++ node ++ protobuf ++ rust;
  extras = with nome.pkgs; [];
  shellHook = &quot;&quot;;
};</pre><p class="">I don’t <em>ever</em> need to use all of my toolchains, so I always start by removing the ones I don’t need. Then, if I need any other specific executables, I add those under <code>extras</code> (<code>nome.pkgs</code> is a re-exported <a href="https://github.com/nixOS/nixpkgs">Nixpkgs</a> pinned to a specific commit, so I can put just about anything here). If I need commands to be run whenever I initialize the environment, I put those in <code>shellHook</code>. The result: it now typically takes me less than a minute to get a project configured to my exact specifications.</p><h3>Bringing my environment to a new machine</h3><p class="">One of the things I like about the single-project approach I’ve adopted is that it’s rather trivial to port it from machine to machine. Let’s say that I accidentally drop my current laptop into the ocean and have to buy one. Here’s what I would need to do to get that new machine up to speed.</p><ol data-rte-list="default"><li><p class=""><a href="https://nixos.org/download.html">Install Nix</a> and <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">enable Nix flakes</a></p></li><li><p class="">Run these commands:</p></li></ol>


<pre class="source-code">nix build &quot;github:the-nix-way/nome#homeConfiguration.lucperkins.activationPackage&quot;
./result/activate</pre><p class="">This creates the initial Home Manager generation on the machine, along with all of my dotfiles, and installs my desired packages with it. I don’t change machines all that often, but it’s nonetheless consoling to know that the effort I’ve put into Nome will never be for naught—unlike those countless hours lost to manual setup in more benighted times.</p><h3>Nome and NixOS</h3><p class="">Nome is also home to my NixOS configuration. Truth be told, I’m a novice NixOS user, so I only have <a href="https://github.com/the-nix-way/nome/tree/main/nixos" target="_blank">one configuration</a> that I’ve been slowly building out—and a pretty simple one at that. But thus far it’s been extremely convenient to kick start NixOS on a VM with just one command:</p>


<pre class="source-code">nixos-rebuild switch \
  --flake &quot;github:the-nix-way/nome#lucperkins&quot;</pre><h3>Nome’s future</h3><p class="">Nome is still very much in its youth but I expect it to be a steady and ever-maturing companion as long as I work in software. I even have a rough roadmap of where I want to take it in the near future:</p><ol data-rte-list="default"><li><p class="">Refine my NixOS configurations to the point where I can use NixOS as my primary development environment, even on macOS. <a href="https://github.com/mitchellh">Mitchell Hashimoto</a>’s illuminating <a href="https://github.com/mitchellh/nixos-config" target="_blank">nixos-config</a> project has emboldened me to take this on. I’ll share details on this journey at a later date.</p></li><li><p class="">Add a <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> configuration to define lower-level details of my macOS environment.</p></li><li><p class="">Refactor my Nix sources to be more modular, so that I can share Nix expressions across, for example, my NixOS configurations, my macOS Home Manager config, and my <code>proj</code> system.</p></li><li><p class="">So far my Home Manager configuration assumes my Apple M1 environment (<code>aarch64-darwin</code> in Nix terms) but I’d like to make it more robust by adding a Linux configuration that I can run on a (future) Linux machine.</p></li></ol>


<h3>Nome’s scope</h3><p class="">Nome is intended only as a personal project. If you find inspiration in it, great! If you want to <code>git clone</code> it and use it as a template, please <a href="https://github.com/the-nix-way/nome/blob/main/LICENSE" target="_blank">feel free</a>. But don’t be surprised if you dislike some of my choices or even my entire approach. My hope isn’t that you follow directly in Nome’s footsteps but rather that it convinces you to see your home environment as your career-long companion and thus worthy of a long-running personal project.</p>]]></content:encoded></item><item><title>Introducing Riff</title><dc:creator>Graham Christensen</dc:creator><pubDate>Tue, 06 Sep 2022 17:00:00 +0000</pubDate><link>https://determinate.systems/posts/introducing-riff</link><guid isPermaLink="false">614cc40992cfe92efbb11fd4:615dfb3b1995b01cb9b11d90:630e19a27e45497c6dd7317b</guid><description><![CDATA[Riff is a tool that automatically provides external dependencies for Rust 
projects]]></description><content:encoded><![CDATA[<p class="">Package managers like <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, <a href="https://pypi.org/project/pip/">pip</a>, and <a href="https://npmjs.org">npm</a> are indispensable tools in software development because they quietly handle language-specific dependencies for you. But unfortunately they’re not so great at installing dependencies written in other languages (we call these <em>external</em> dependencies). One of the classic examples is <a href="https://nokogiri.org">Nokogiri</a>, a widely used XML and HTML parser for <a href="https://ruby-lang.org">Ruby</a>, whose dependency on a C library called <a href="https://github.com/GNOME/libxml2" target="_blank">libxml2</a> has caused great consternation for Ruby devs over the years. More recently, external dependencies like <a href="https://openssl.org/" target="_blank">OpenSSL</a> and <a href="https://www.gnu.org/software/libiconv/" target="_blank">libiconv</a> have proven troublesome for <a href="https://rust-lang.org">Rust</a> developers.</p><p class="">One half-solution to this problem is to list these external dependencies in the project’s documentation so that developers can install them on their own. Sometimes, projects go a bit beyond that, providing detailed installation instructions for developers in different situations. And occasionally, external dependencies aren’t even mentioned and developers are on their own to provide them, which usually means Googling and StackOverflowing—and wasted time.</p><p class="">Like many of you, we’ve grown weary of half-solutions. We want to be able to clone a project, <code>cd</code> in, and have external dependencies quietly taken care of, and so we built a tool called <a href="https://github.com/DeterminateSystems/riff" target="_blank">Riff</a> that addresses this problem head on. Today, we at <a href="https://determinate.systems/" target="_blank">Determinate Systems</a> are thrilled to announce its initial release.</p><h3>Introducing Riff</h3><p class="">Riff is a tool that we built to help developers write software without having to wrangle dependencies or complicated configuration. It’s built to enable you to clone a project and get to work in seconds. It’s currently <a href="https://github.com/determinateSystems/riff#installation">available</a> for macOS and standard Linux systems. Upon this initial release, Riff supports <a href="https://rust-lang.org">Rust</a> projects built with <a href="https://www.notion.so/Introducing-Riff-13046dd993b24189a5c73abac98a260d">Cargo</a> but we have plans to provide support for other languages, such as <a href="https://go.dev">Go</a> and the <a href="https://javascript.com">JavaScript</a> ecosystem, in the future.</p><p class="">Riff is powered by <a href="https://nixos.org/nix">Nix</a>, the purely functional language and package manager behind <a href="https://nixos.org/">NixOS</a>, <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a>, and many other projects. But don’t worry: we built Riff to solve your problems without requiring you to use, understand, or even care about Nix at all. Riff is <em>powered by</em> Nix but not another Nix tool.</p><p class="">So let’s take a look at Riff in action. <a href="https://github.com/tokio-rs/prost">Prost</a> is a popular Rust crate that provides a <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> implementation for Rust. But on most systems, the build is doomed to fail due to missing external dependencies:</p>


<pre class="source-code">git clone https://github.com/tokio-rs/prost
cd prost
cargo build</pre><p class="">On Linux you get a <code>linker cc not found</code> error, while on macOS you get <code>library not found for -liconv</code> errors. Annoying! Even worse, any project that depends on <code>prost</code> produces the same error. Now let’s try it with <a href="https://github.com/DeterminateSystems/riff">Riff</a>:</p>


<pre class="source-code">riff run cargo build</pre><p class="">And it works! So what has happened here? Riff has:</p><ul data-rte-list="default"><li><p class="">read your project’s <code>Cargo.toml</code>,</p></li><li><p class="">determined which external dependencies are necessary based on your crate dependency graph,</p></li><li><p class="">used Nix, with zero user input, to install external dependencies in <code>/nix/store</code>, and finally</p></li><li><p class="">assembled a shell environment that doesn’t interfere with anything else on your system.</p></li></ul><p class="">The <code>cargo build</code> command here runs inside that Nix-built shell environment. In fact, you can enter that environment at any time and run arbitrary commands:</p>


<pre class="source-code">riff shell

# Enter the Riff shell

cargo run
cargo build
cargo clippy

exit

# Back to your standard shell</pre><p class="">For more on Riff, including instructions for <a href="https://github.com/determinateSystems/riff#how-to-declare-package-inputs">explicitly specifying</a> external dependencies in your <code>Cargo.toml</code> or using Riff with <a href="https://direnv.net">direnv</a>, see the project <a href="https://github.com/determinateSystems/riff">README</a>.</p><p class="">The first time we showed Riff to a user, they were quite surprised and even confused: how could it have been so straightforward? What on Earth quietly happened in the background? That's the energy we're going for with Riff: development environments that just work and require, at most, a teensy bit of configuration.</p><p class="">We’re confident that Riff will provide lasting benefits to the Rust ecosystem (and other ecosystems later). Rust is a fantastic language with incredible tools but it has its limits. External dependency problems introduce breakage points into the dependency graphs of <em>many</em> Rust projects. With Riff we hope to cover this “last mile” problem in Rust development and make the entire developer experience more robust.</p><h3>Future horizons</h3><p class="">We’ve kept our ambitions moderate in this initial release, but we still think that Riff will prove to be an indispensable tool for Rust developers—and others in the future. But Nix offers much more power that Riff could potentially tap into, including the ability to generate <a href="https://opencontainers.org">OCI</a> images, <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-concepts.html#gettingstarted-concepts-layer">AWS Lambda layers</a>, or even packages for Nix and other package managers. We’re anxious to continue solving thorny, un-fun problems for developers, so stay tuned for more magic from Riff, including support for Go and JavaScript in the near future.</p><h3>Discussion</h3><p class="">If you’d like to discuss Riff with other users, you can join the <a href="https://discord.gg/urAzkgf7YM">Discord</a> for Riff.</p>]]></content:encoded></item><item><title>We want to make Nix better</title><dc:creator>Graham Christensen</dc:creator><pubDate>Fri, 02 Sep 2022 17:00:00 +0000</pubDate><link>https://determinate.systems/posts/we-want-to-make-nix-better</link><guid isPermaLink="false">614cc40992cfe92efbb11fd4:615dfb3b1995b01cb9b11d90:6310f4509c10b91b94094db3</guid><description><![CDATA[Introducing Determinate Systems, a company devoted to bringing the immense 
benefits of Nix to the software world. Our values, our mission, and what 
the future holds.]]></description><content:encoded><![CDATA[<p class=""><a href="https://nixos.org">Nix</a> is immensely powerful but it can have quite the steep learning curve. Numerous people in our industry hotly desire what Nix has to offer: hermetic development environments, fully reproducible package builds, declaratively configured operating systems. But even those who are aware of Nix’s benefits know that actually <em>using</em> Nix to solve real problems has some jagged edges. The Nix <a href="https://nixos.wiki/wiki/Overview_of_the_Nix_Language">expression language</a> is a bit odd coming from most other languages, the <a href="https://nixos.org/guides/how-nix-works.html">core concepts</a> aren’t always super digestible, the <a href="https://nixos.org/manual/nix/stable/package-management/basic-package-mgmt.html">package manager</a> is unlike apt, deb, Homebrew and the rest—all in all, it’s just a different paradigm of doing things that requires a substantial investment of time and energy.</p><p class="">At <a href="https://determinate.systems">Determinate Systems</a>, we <em>love</em> Nix, but to those who don’t love it enough to make that investment: we hear you. Many folks in software engineering, even some seasoned Nix veterans, feel that Nix’s sterling feature set often comes at too high a cost. It’s easy enough to convince your team or your boss that Nix <em>could</em> have a transformative impact, but convincing people to commit the resources to adopt Nix is another matter. Other tools and approaches may be good enough to get the job done well enough and call it a day; best to stick with a just-okay but known quantity. For those who are passionate about Nix, this can be a tough pill to swallow.</p><h3>Our mission</h3><p class="">We’re confident that we can break this impasse. Our objective at Determinate Systems is to enable people across the software world to reap the many benefits of Nix without nearly as much effort—and occasional pain—as Nix has demanded in the past. In some cases, that will mean that we improve the experience of using Nix itself by contributing to the Nix ecosystem. But in other cases it will mean giving users access to Nix’s wonderful features without requiring them to use it directly, letting Nix quietly do its vital work in the background while exposing few if any internals.</p><p class="">We love Nix because it solves a wide range of problems with aplomb. Those who have used it directly—to build a package, to configure a <a href="https://nixos.org">NixOS</a> system, to create a development environment—have a keen sense of its power. But we know that it isn’t reasonable to make learning and struggling with Nix a condition of benefiting from it. All programming languages and paradigms require an investment, but Nix is meant to <em>facilitate</em> software development, not be the center of attention. It’s supposed to help you write, distribute, and deploy <a href="https://rust-lang.org">Rust</a>, <a href="https://go.dev">Go</a>, <a href="https://python.org">Python</a>, <a href="https://javascript.com">JavaScript</a>, and others. Helping those who have already invested in Nix is very much part of our mission—but so is helping those who want a better way to ship software without taking on a new learning project.</p><h3>A representative problem</h3><p class="">Let’s make this more concrete by talking about a specific problem that we’re currently looking into: the problem of <em>external dependencies</em>. These are dependencies that are written in a different language from the one you’re currently developing in. Some examples: the <a href="https://developers.google.com/protocol-buffers">Protobuf</a> compiler, <code>protoc</code>, is a problem in <a href="https://rust-lang.org">Rust</a> projects because it’s written in C++; <a href="https://nokogiri.org">Nokogiri</a> is a problem in Ruby projects because it’s written in C; and <a href="https://openssl.org">OpenSSL</a> presents a problem in all kinds of languages. Ideally we’d all be able to <code>git clone</code> and <code>cd</code> into any software project and immediately start building and testing, but we all know the experience of Googling and StackOverflowing just to get off the ground.</p><p class="">Fortunately, the external dependency problem already has a solution: <strong>Nix</strong>! You can use Nix to configure a <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">shell environment</a> with all the necessary dependencies installed. A Python project that requires OpenSSL? No problem. A Haskell project that requires <a href="https://asciidoc.org">Asciidoc</a>? No problem. Need to share those environments across teams and port them to your continuous integration system? No problem.</p><p class="">But there’s a catch: to make that happen you need to write some Nix, use Nix tools, and probably consult several documentation sources. If you’re already using Nix to solve external dependency problems, great! You’re in good company. But this is the kind of problem we want to solve for people who don’t have the bandwidth or the desire to learn Nix.</p><h3>Where we go from here</h3><p class="">The external dependency problem is far from alone. It’s part of a vast constellation of interrelated problems that make developing, distributing, and deploying software much more brittle, complicated, and resource intensive than they should be. In Nix, we as an industry have <em>the</em> tool to take an enormous chunk out of these kinds of problems. At Determinate Systems, we’re committed to being a major driving force behind this. We’ll have some specific—and exciting—announcements about our approach to the external dependency problem—amongst others—very soon, so stay tuned here on our <a href="https://determinate.systems/posts">blog</a>, in the <a href="https://github.com/DeterminateSystems">DeterminateSystems</a> GitHub organization, and <a href="https://twitter.com/DeterminateSys">on Twitter</a>.</p>]]></content:encoded></item><item><title>How to Use Hydra as your Deployment Source of Truth</title><dc:creator>Graham Christensen</dc:creator><pubDate>Thu, 14 Oct 2021 19:40:32 +0000</pubDate><link>https://determinate.systems/posts/hydra-deployment-source-of-truth</link><guid isPermaLink="false">614cc40992cfe92efbb11fd4:615dfb3b1995b01cb9b11d90:616883518583ba679025c925</guid><description><![CDATA[Hydra is a fantastic tool for building small and large software 
collections. It is also a great tool for orchestrating releases.]]></description><content:encoded><![CDATA[<p class=""><a href="https://github.com/nixos/hydra" target="">Hydra is the Nix-based continuous integration system</a> for the NixOS project. It is designed around evaluating a project’s Nix expressions and walking the graph of build jobs. Hydra is a fantastic tool for building small and large software collections. It is also a great tool for orchestrating releases.</p><p class="">Hydra's API includes dynamic links that point to the most recent build of a job. Using this interface, deployment tools can query Hydra for the most recent artifact to deploy.</p><h1>Fetching the Latest Build</h1><p class="">Starting from a jobset named <code>myapp:main</code> that builds your application with the following <code>hydra.nix</code> file:</p><pre><code>{ nixpkgs ? &lt;nixpkgs&gt; }:
let
  pkgs = import nixpkgs { };
in
{
  myapp = pkgs.writeShellScript "hello" "${pkgs.hello}/bin/hello";
}
</code></pre><p class="">The Hydra API includes a "latest" URL to find the most recent, successful build of the <code>myapp</code> job. You can find this by visiting the jobset's root page, clicking Jobs, clicking <code>myapp</code>, then the "Links" tab. In my case, the URL is <a href="https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest">https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest</a>.</p><p class="">Fetching this URL will redirect to the completed build:</p><pre><code>$ curl --location \
      --header "Accept: application/json"
      https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest \
    | jq .
{
  "id": 70,
  "finished": 1,
  "stoptime": 1634228145,
  "timestamp": 1634228145,
  "buildstatus": 0,
  "buildproducts": {},
  "project": "myapp",
  "system": "x86_64-linux",
  "buildmetrics": {},
  "job": "myapp",
  "starttime": 1634228145,
  "nixname": "hello",
  "buildoutputs": {
    "out": {
      "path": "/nix/store/c3l2x6fwl8cjkmfz6ilqcgczk13w8bk2-hello"
    }
  },
  "drvpath": "/nix/store/gf5wshlqfk1xa4i6ibk0z1l3j441c7vl-hello.drv",
  "jobset": "main",
  "jobsetevals": [
    296
  ],
  "priority": 100,
  "releasename": null
}</code></pre><p class=""><em>Note: There is another useful URL that links to the most recent passing build of the job with the additional requirement that there must not be any queued jobs left in the evaluation. This is useful for maximizing the amount of builds that are cached, but does not imply that all the jobs passed. That URL is the "latest-finished" URL: </em><a href="https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest-finished.*"><em>https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest-finished</em></a><em>.</em></p><h2>Deploying Software and Servers from Hydra</h2><p class="">You could imagine a deployment process that consumes the most recent build of <code>myapp</code> and automatically updates a local symlink:</p><pre><code>$ app_path=$(curl --location \
      --header "Accept: application/json" \
      https://demo.cloudscalehydra.com/job/myapp/main/myapp/latest \
    | jq -r .buildoutputs.out.path)
$ nix-env -p /nix/var/nix/profiles/production --set "$app_path"
</code></pre><p class="">Indeed, if you're running NixOS, you could build entire NixOS system configurations in Hydra and deploy to your clients the same way:</p><pre><code>$ system_path=$(curl --location \
      --header "Accept: application/json" \
      https://demo.cloudscalehydra.com/job/servers/main/$(hostname)/latest \
    | jq -r .buildoutputs.out.path)
$ nix-env --profile /nix/var/nix/profiles/system --set "$system_path"
$ /nix/var/nix/profiles/system/bin/switch-to-configuration switch
</code></pre><h2>Monitoring Build Status</h2><p class="">Hydra exports Prometheus metrics for every job:</p><pre><code>$ curl https://demo.cloudscalehydra.com/job/myapp/main/myapp/prometheus
# HELP hydra_job_completion_time The most recent job's completion time
# TYPE hydra_job_completion_time counter
hydra_job_completion_time{project="myapp",jobset="main",job="myapp"} 1634228145
# HELP hydra_job_failed Record if the most recent version of this job failed (1 means failed)
# TYPE hydra_job_failed gauge
hydra_job_failed{project="myapp",jobset="main",job="myapp"} 0</code></pre><p class="">You can track and page on <code>failed</code>, or monitor <code>completion_time</code> to ensure that you never let a project go more than a few days without a completed build.</p><h1>Gating Releases on Tests</h1><p class="">The <code>myapp</code> example above will work great for some projects, but sometimes the software or system you're deploying is much more complicated.</p><p class="">It may not be practical to run all of your software's test validation in a single build.</p><p class="">In this case you want to deploy <code>myapp</code>, but you want to gate on some other build jobs succeeding too.</p><p class="">One solution is to make one job that depends on your other jobs. You can do that by adding a job to your <code>hydra.nix</code> that lists the other jobs in a text file:</p><pre><code>{ nixpkgs ? &lt;nixpkgs&gt; }:
let
  pkgs = import nixpkgs { };
in
rec {
  myapp = pkgs.writeShellScript "hello" "${pkgs.hello}/bin/hello";
  myapp_test_does_it_run = pkgs.runCommand "test-hello" { } ''${myapp} &gt; $out'';
  release_gate = pkgs.writeText "test-dependencies" ''
    ${myapp}
    ${myapp_test_does_it_run}
  '';
}</code></pre><p class="">This method will create a job, <code>release_gate</code>, which only passes if <code>myapp</code> builds and runs. It also poses a problem: how do you get from <code>release_gate</code> to <code>myapp</code>? One option could be parsing the contents of this <code>release_gate</code> file, but that is fairly ugly. Another problem is when a test fails, Hydra doesn't tell you a lot about what went wrong:</p><p data-rte-preserve-empty="true" class=""></p><p class="">If your software has one or two tests, this might work, but this will be tedious with more than a handful of jobs you want to gate on.</p><h1>Aggregate Jobs</h1><p class="">Hydra's Aggregate Jobs is a special type of job that addresses both of these problems.</p><p class="">Rewriting our previous example with an aggregate job involves making a list of "constituents" (the jobs you depend on) and setting the <code>_hydraAggregate</code> attribute:</p><pre><code>{ nixpkgs ? &lt;nixpkgs&gt; }:
let
  pkgs = import nixpkgs { };
in
rec {
  myapp = pkgs.writeShellScript "hello" "${pkgs.hello}/bin/hello";
  myapp_test_does_it_run = pkgs.runCommand "test-hello" { } ''${myapp} &gt; $out'';

  release_gate = pkgs.runCommand "test-dependencies"
    {
      _hydraAggregate = true;
      constituents = [
        myapp
        myapp_test_does_it_run
      ];
    } "touch $out";
}</code></pre><p class="">This build task is trivial and the <em>build product</em> <em>itself</em> isn't useful. The valuable part is the proof that all our important dependencies built successfully. Our release process can check to see if the <code>release_gate</code> build finished, and proceed if it did.</p><p class="">Hydra displays aggregate jobs differently. The build page for an Aggregate Job lists the named constituent jobs and their statuses:</p><p data-rte-preserve-empty="true" class=""></p><p class="">The page for the job itself also shows the constituent jobs and their status history:</p><p data-rte-preserve-empty="true" class=""></p><p class="">Using the <code>latest-finished</code> URL, you can get the most recent build where all the tests passed, and then fetch that build's constituents:</p><pre><code>$ build_id=$(curl --silent --location \
    --header "Accept: application/json" \
    https://demo.cloudscalehydra.com/job/myapp/main/release_gate/latest-finished | jq .id
$ curl --silent \
    --header "Accept: application/json" \
    "https://demo.cloudscalehydra.com/build/$build_id/constituents" | jq
[
  {
    "job": "myapp",
    "drvpath": "/nix/store/gf5wshlqfk1xa4i6ibk0z1l3j441c7vl-hello.drv",
    "id": 70,
    "releasename": null,
    "priority": 100,
    "timestamp": 1634228145,
    "finished": 1,
    "starttime": 1634228145,
    "system": "x86_64-linux",
    "buildmetrics": {},
    "jobset": "main",
    "nixname": "hello",
    "buildstatus": 0,
    "buildoutputs": {
      "out": {
        "path": "/nix/store/c3l2x6fwl8cjkmfz6ilqcgczk13w8bk2-hello"
      }
    },
    "project": "myapp",
    "jobsetevals": [
      296,
      303,
      307,
      310,
      313,
      314,
      315
    ],
    "buildproducts": {},
    "stoptime": 1634228145
  },
  {
    "jobset": "main",
    "nixname": "test-hello",
    "buildstatus": 0,
    "buildoutputs": {
      "out": {
        "path": "/nix/store/zvs873fz97pwc91dk76dvzmnilj6mvis-test-hello"
      }
    },
    "project": "myapp",
    "jobsetevals": [
      314
    ],
    "buildproducts": {},
    "stoptime": 1634230682,
    "job": "myapp_test_does_it_run",
    "drvpath": "/nix/store/d36l0zyp5vxiqyird8m9p2jivzf0k67z-test-hello.drv",
    "releasename": null,
    "id": 78,
    "priority": 100,
    "timestamp": 1634230682,
    "finished": 1,
    "starttime": 1634230682,
    "buildmetrics": {},
    "system": "x86_64-linux"
  }
]</code></pre><p class="">Applying a little bit more <code>jq</code> we can get the exact path to the <code>myapp</code> build:</p><pre><code>$ build_id=$(curl --silent --location \
    --header "Accept: application/json" \
    https://demo.cloudscalehydra.com/job/myapp/main/release_gate/latest-finished | jq .id
$ curl --silent \
      --header "Accept: application/json" \
      "https://demo.cloudscalehydra.com/build/$build_id/constituents" \
    | jq -r '.[] | select(.job == "myapp") | .buildoutputs.out.path'
/nix/store/c3l2x6fwl8cjkmfz6ilqcgczk13w8bk2-hello</code></pre><h3>Scaling Aggregate Jobs</h3><p class="">For aggregate jobs that have a very large evaluation graph, the evaluator's memory footprint can exhaust the host's available memory. This is especially easy if your constituents include a lot of NixOS tests, or your jobset is evaluating a lot of NixOS system closures.</p><p class="">Since Hydra's main design motivation is to be NixOS's CI system and NixOS's <code>tested</code> job depends on a lot of NixOS tests, Hydra has developed a small extension to Nix's semantics to allow for more efficient aggregate jobs, allowing Nix's garbage collector to free memory early.</p><p class="">Changing our example hydra.nix a little, we get the same behavior but allow the evaluator's garbage collector to free some memory. Instead of listing derivations as constituents, Hydra allows you to specify constituent jobs using the job's name as a string:</p><pre><code>{ nixpkgs ? &lt;nixpkgs&gt; }:
let
  pkgs = import nixpkgs { };
in
rec {
  myapp = pkgs.writeShellScript "hello" "${pkgs.hello}/bin/hello";
  myapp_test_does_it_run = pkgs.runCommand "test-hello" { } ''${myapp} &gt; $out'';

  release_gate = pkgs.runCommand "test-dependencies"
    {
      _hydraAggregate = true;
      constituents = [
        "myapp"
        "myapp_test_does_it_run"
      ];
    } "touch  $out";
}</code></pre><p class="">Hydra's evaluator will notice that the listed constituents are <em>not</em> derivations and are in fact regular strings. It will then look up these attributes in the list of jobs in the jobset and <em>rewrite the derivation</em>, substituting the plain string with the derivation path.</p><p class="">Note that while Hydra will be much more efficient at evaluating the <code>release_gate</code> job, Nix and other tools will not be able to evaluate and build the release gate in the same way.</p><h3>An Aggregate of All Jobs</h3><p class="">If you wanted your release gate to depend on <em>all</em> of the build jobs passing, a little bit of Nix can automatically create an aggregate job of all the other jobs:</p><pre><code>{ nixpkgs ? &lt;nixpkgs&gt; }:
let
  pkgs = import nixpkgs { };
  jobs = rec {
    myapp = pkgs.writeShellScript "hello" "${pkgs.hello}/bin/hello";
    myapp_test_does_it_run = pkgs.runCommand "test-hello" { } ''${myapp} &gt; $out'';
  };
in
jobs // {
  release_gate = pkgs.runCommand "test-dependencies"
    {
      _hydraAggregate = true;
      constituents = builtins.attrNames jobs;
    } "touch  $out";
}</code></pre><h1>Recap</h1><p class="">Hydra is uniquely capable of building Nix projects, and using Hydra's Aggregate Jobs provides deeper insight into the state and health of your project. Almost all of the data on <a href="https://status.nixos.org">https://status.nixos.org</a> comes from Hydra's Prometheus exporter, and you might notice the "Hydra job for tests" link goes to an aggregate jobset. The NixOS project has used aggregate jobs and the <code>latest-finished</code> URLs to manage releasing expression for years.</p><p class="">Using Nix together with Hydra's unique feature set and API can give good visibility in to your test suite, and allows you to deploy with confidence.</p><p class=""><em>If you'd like a managed Hydra server as a service, check out the first product we're building: </em><a href="https://cloudscalehydra.com"><em>Cloudscale Hydra</em></a><em>.</em></p>]]></content:encoded></item><item><title>Announcing: terraform-provider-hydra</title><dc:creator>Cole Helbling</dc:creator><pubDate>Mon, 17 May 2021 15:11:00 +0000</pubDate><link>https://determinate.systems/posts/terraform-provider-hydra</link><guid isPermaLink="false">614cc40992cfe92efbb11fd4:615dfb3b1995b01cb9b11d90:615dfb3b1995b01cb9b11d97</guid><description><![CDATA[I'm excited to announce Determinate Systems' first open source release: a 
Terraform provider for managing Hydra projects and jobsets.]]></description><content:encoded><![CDATA[<p class="">I'm excited to announce Determinate Systems' first open source release: <a href="https://github.com/DeterminateSystems/terraform-provider-hydra/">terraform-provider-hydra</a>, a Terraform provider for managing Hydra projects and jobsets.</p><p class=""><strong>Standardize jobset configuration.</strong> Manage your Hydra  jobsets with the rest of your critical infrastructure. Know your jobsets  are configured correctly. Apply standard PR workflows to approve  changes and ensure operational consistency.</p><p class=""><strong>Reduce risk exposure.</strong> Exchange highly privileged users and manual changes for automation and auditable logs. Remove high-level <code>create-project</code> and <code>admin</code> permissions from most users, and deploy configuration changes through Terraform instead.</p><p class=""><strong>Reduce configuration overhead.</strong> Directly manage your  jobsets with the rest of your infrastructure in a consistent and  predictable way. Save Hydra's generated declarative jobsets for when you  truly need dynamically generated jobsets.</p><p class="">We're big fans of Hydra. Its native understanding of Nix closures  makes it a first class build system for Nix projects. The scheduler and  built-in distributed build support allows for distributing work to an  automatically scaled build pool of builders.</p><p class="">Now you can configure your Hydra with the same tool you use to manage the rest of your infrastructure.</p><h3>Declarative configuration, at the CI level</h3><p class="">Hydra deployments are usually a central root of trust. Using projects  and jobsets, Hydra can provide a lookup table and audit log, mapping  use cases to tested revisions of code. However Hydra does not provide an  audit log of configuration changes to a jobset. The input configuration  is the keystone to the validity of that mapping.</p><p class="">Using Terraform as the source of configuration truth solves a number of problems presented by hand-managed configuration:</p><ol data-rte-list="default"><li><p class="">Managing inputs by hand poses a risk of misconfiguration and drift between jobsets. As configuration changes over time, older jobsets are less likely to be updated.</p></li><li><p class="">Permission to modify a jobset is only granted to administrators and the "owner" of a project. Configuring a jobset across a team requires granting high level, administrative-level access to the entire team.</p></li><li><p class="">Changes are unlikely to be noticed. The jobset could be changed to point to an alternative source repository or branch without anyone noticing. The lack of an audit log or other guarantees makes it difficult to notice changes to jobsets which are not actively monitored.</p></li></ol><h3>Audits, robust access control, and effective delegation</h3><p class="">Managing your Hydra's configuration through Terraform resolves all of  these issues at once. Inputs are tracked and managed holistically,  across the entire server, from the same source of truth. Users no longer  need their own administrative credentials: any changes should go  through a Continuous Delivery pipeline with its own credentials, just  like everyone else. Additionally, any divergence of a Terraform managed  Jobset or Project is identified and corrected on the next run of  Terraform.</p><h2>Get started</h2><p class="">Your Hydra will need to be running version <a href="https://github.com/NixOS/hydra/commit/6e537671dfa21f89041cbe16f0b461fe44327038">6e537671</a> or later, which is already available in the nixos-unstable, nixos-unstable-small, nixos-20.09, and nixos-20.09-small channels.</p><p class="">Then, install the provider as documented in the <a href="https://github.com/DeterminateSystems/terraform-provider-hydra/#getting-started">project's README</a>.</p><p class="">From there, we recommend starting by importing your existing configuration.</p><h3>Migrating an existing instance</h3><p class="">Clone the repository to get started:</p><pre><code>$ git clone https://github.com/DeterminateSystems/terraform-provider-hydra.git
$ cd terraform-provider-hydra/tools
$ nix-shell</code></pre><p class="">Then, run the generator:</p><pre><code>[nix-shell]$ mkdir network
[nix-shell]$ ./generator.sh https://hydra.example.com ./network ./network/imports.sh</code></pre><p class="">The generator will create one file per project in <code>./network</code>, and <code>./network/imports.sh</code> will contain a list of <code>terraform import</code> commands to execute.</p><p class="">Execute those commands:</p><pre><code>$ bash ./network/imports.sh</code></pre><p class="">and then you're done! <code>terraform plan</code> should show no differences to be applied.</p><h2>What's next</h2><p class="">Take a <a href="https://github.com/DeterminateSystems/terraform-provider-hydra/">look at the code</a>, give it a try. Let us know what you think!</p><p class="">Since May 5th, we have continuously run the <a href="https://github.com/DeterminateSystems/hydra-nixos-org-configuration/tree/main/config">importer against hydra.nixos.org and checked the resulting plan is clean</a>.  So far so good: each configuration change has worked flawlessly with  the provider and the importer. We hope the NixOS infrastructure team  will adopt this provider and manage the public Hydra with code.</p><p class="">Since our founding just a few months ago, we've made significant  investments into Hydra's long term stability and maintainability. We see  Hydra as a cornerstone of the Nix ecosystem, and we're planning to  continue our investment over the long term. Look out in the near future  for performance improvements for large deployments.</p>]]></content:encoded></item></channel></rss>
