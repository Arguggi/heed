{-# LANGUAGE Arrows #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Heed.Database where

import Data.Aeson
import Data.Profunctor.Product.TH (makeAdaptorAndInstance)
import Data.Text (Text)
import Data.Time.Calendar (fromGregorian)
import Data.Time.Clock (UTCTime(..), secondsToDiffTime)
import GHC.Generics
import Heed.Commands
import Heed.DbEnums
import qualified Opaleye as O

-- * Define database types
-- Type name guide:
-- W = Write
-- R = Read
-- H = Haskell world
-- WO = Write Optional
-- Users Table
type Url = Text

-- | PostgreSQL User Table
data User a b c d = User
    { userId :: a -- ^ PGInt4
    , userName :: b -- ^ Text
    , userPassword :: c -- ^ Bytestring
    , userEmail :: c -- ^ Text
    }

-- | For additional typesafety
newtype UserId a = UserId
    { getUserId :: a
    } deriving (Functor)

-- | User in Haskell Land
type UserH = User (UserId Int) Text Text Text

-- | PostgreSQL Feeds Table
data FeedInfo a b c d e f g = FeedInfo
    { feedInfoId :: a -- ^ Autogenerated PGInt4
    , feedInfoName :: b -- ^ Feed Name
    , feedInfoUrl :: c -- ^ Feed url
    , feedInfoUpdateEvery :: d -- ^ Update every minutes
    , feedInfoLastUpdated :: e -- ^ Last time the feed was downloaded and items added to the db
    , feedHasItemDate :: f -- ^ If the items in the feed have a publication date
    , feedNumberItems :: g -- ^ If no publication date is present we download the last
      -- x items to check so we can check which items in the feed are new
    } deriving (Show, Generic)

-- | For additional typesafety
newtype FeedInfoId a = FeedInfoId
    { getFeedInfoId :: a
    } deriving (Functor, Show, Generic)

instance FromJSON FeedInfoIdH

instance ToJSON FeedInfoIdH

-- | 'FeedInfoId' Haskell
type FeedInfoIdH = FeedInfoId Int

-- | 'FeedInfo' Haskell read from DB
type FeedInfoHR = FeedInfo (FeedInfoId Int) Text Text Int UTCTime ItemsDate Int

-- | 'FeedInfo' Haskell write to DB (Id is missing)
type FeedInfoHW = FeedInfo (FeedInfoId (Maybe Int)) Text Text Int UTCTime ItemsDate Int

instance FromJSON FeedInfoHR

instance ToJSON FeedInfoHR

-- | PostgreSQL Feeds <-> Users (Subscriptions) Table
data Subscription a b = Subscription
    { subscriptionFeedId :: a -- ^ Foreign key on FeedInfoId
    , subscriptionUserId :: b -- ^ Foreign key on UserId
    }

-- | PostgreSQL Feed items Table
data FeedItem a b c d e f = FeedItem
    { feedItemId :: a -- ^ Autogenerated PGInt4
    , feedItemFeedId :: b -- ^ Foreign Key to FeedInfoId PGInt4
    , feedItemTitle :: c -- ^ Item title Text
    , feedItemUrl :: d -- ^ Item url Url
    , feedItemDate :: e -- ^ Item date
    , feedItemComments :: f -- ^ Comment url if available (ala HN)
    }

-- | For additional typesafety
newtype FeedItemId a = FeedItemId
    { getFeedItemId :: a
    } deriving (Functor, Show, Generic)

-- | FeedItemId Haskell
type FeedItemIdH = FeedItemId Int

instance ToJSON FeedItemIdH

instance FromJSON FeedItemIdH

-- | 'FeedItem' Haskell read from DB
type FeedItemHR = FeedItem (FeedItemId Int) (FeedInfoId Int) Text Url UTCTime (Maybe Url)

-- | 'FeedItem' Haskell write to DB (ItemId is missing)
type FeedItemHW = FeedItem (FeedItemId (Maybe Int)) (FeedInfoId (Maybe Int)) Text Url UTCTime (Maybe Url)

-- | Unread items
data UnreadItem a b = UnreadItem
    { unreadFeedItemId :: a -- ^ Foreign key on FeedItemId -- PGInt4
    , unreadUserId :: b -- ^ Foreign key on UserId -- PGInt4
    }

-- | PostgreSQL Authentication token table
data AuthToken a b = AuthToken
    { authTokenHeedUserId :: a -- ^ Foreign key on UserId -- PGInt4
    , authTokenToken :: b -- ^ Randomly generated token -- Text
    }

$(makeAdaptorAndInstance "pUser" ''User)

$(makeAdaptorAndInstance "pUserId" ''UserId)

type UserW = User UserIdColumnWO (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGText)

type UserR = User UserIdColumnR (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGText)

type UserIdColumnWO = UserId (Maybe (O.Column O.PGInt4))

type UserIdColumnW = UserId (O.Column O.PGInt4)

type UserIdColumnR = UserId (O.Column O.PGInt4)

userTable :: O.Table UserW UserR
userTable =
    O.Table
        "heed_user"
        (pUser
             User
             { userId = pUserId (UserId (O.optional "id"))
             , userName = O.required "username"
             , userPassword = O.required "password"
             , userEmail = O.required "email"
             })

-----------------------------------------
-- Feeds Table
$(makeAdaptorAndInstance "pFeedInfo" ''FeedInfo)

$(makeAdaptorAndInstance "pFeedInfoId" ''FeedInfoId)

type FeedInfoW = FeedInfo FeedInfoIdColumnWO (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGInt4) (O.Column O.PGTimestamptz) (O.Column PGItemsDate) (O.Column O.PGInt4)

type FeedInfoR = FeedInfo FeedInfoIdColumnR (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGInt4) (O.Column O.PGTimestamptz) (O.Column PGItemsDate) (O.Column O.PGInt4)

type FeedInfoIdColumnWO = FeedInfoId (Maybe (O.Column O.PGInt4))

type FeedInfoIdColumnW = FeedInfoId (O.Column O.PGInt4)

type FeedInfoIdColumnR = FeedInfoId (O.Column O.PGInt4)

setTime :: UTCTime -> FeedInfoR -> FeedInfoW
setTime utc feedInfo =
    feedInfo
    { feedInfoId = FeedInfoId $ Just (getFeedInfoId . feedInfoId $ feedInfo)
    , feedInfoLastUpdated = O.pgUTCTime utc
    }

defFeedInfo :: FeedInfoHW
defFeedInfo =
    FeedInfo
    { feedInfoId = FeedInfoId Nothing
    , feedInfoName = ""
    , feedInfoUrl = ""
    , feedInfoUpdateEvery = 60
    , feedInfoLastUpdated = defTime
    , feedHasItemDate = Missing
    , feedNumberItems = 20
    }

defTime :: UTCTime
defTime = UTCTime (fromGregorian 0 0 0) (secondsToDiffTime 0)

feedInfoTable :: O.Table FeedInfoW FeedInfoR
feedInfoTable =
    O.Table
        "feed_info"
        (pFeedInfo
             FeedInfo
             { feedInfoId = pFeedInfoId (FeedInfoId (O.optional "id"))
             , feedInfoName = O.required "name"
             , feedInfoUrl = O.required "url"
             , feedInfoUpdateEvery = O.required "update_every"
             , feedInfoLastUpdated = O.required "last_updated"
             , feedHasItemDate = O.required "has_item_date"
             , feedNumberItems = O.required "number_items"
             })

----------------------------
-- Feeds <-> Users (Subscriptions)
$(makeAdaptorAndInstance "pSubscription" ''Subscription)

type SubscriptionW = Subscription FeedInfoIdColumnW UserIdColumnW

type SubscriptionR = Subscription FeedInfoIdColumnR UserIdColumnR

subscriptionTable :: O.Table SubscriptionW SubscriptionR
subscriptionTable =
    O.Table
        "subscription"
        (pSubscription
             Subscription
             { subscriptionFeedId = pFeedInfoId (FeedInfoId (O.required "feed_info_id"))
             , subscriptionUserId = pUserId (UserId (O.required "user_id"))
             })

----------------------------
-- Feed items
$(makeAdaptorAndInstance "pFeedItem" ''FeedItem)

$(makeAdaptorAndInstance "pFeedItemId" ''FeedItemId)

type FeedItemW = FeedItem FeedItemIdColumnWO FeedInfoIdColumnW (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGTimestamptz) (O.Column (O.Nullable O.PGText))

type FeedItemR = FeedItem FeedItemIdColumnR FeedInfoIdColumnR (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGTimestamptz) (O.Column (O.Nullable O.PGText))

type FeedItemIdColumnWO = FeedItemId (Maybe (O.Column O.PGInt4))

type FeedItemIdColumnW = FeedItemId (O.Column O.PGInt4)

type FeedItemIdColumnR = FeedItemId (O.Column O.PGInt4)

defFeedItem :: FeedItemHW
defFeedItem =
    FeedItem
    { feedItemId = FeedItemId Nothing
    , feedItemFeedId = FeedInfoId Nothing
    , feedItemTitle = ""
    , feedItemUrl = ""
    , feedItemDate = defTime
    , feedItemComments = Nothing
    }

feedItemTable :: O.Table FeedItemW FeedItemR
feedItemTable =
    O.Table
        "feed_item"
        (pFeedItem
             FeedItem
             { feedItemId = pFeedItemId (FeedItemId (O.optional "id"))
             , feedItemFeedId = pFeedInfoId (FeedInfoId (O.required "feed_info_id"))
             , feedItemTitle = O.required "title"
             , feedItemUrl = O.required "url"
             , feedItemDate = O.required "pub_date"
             , feedItemComments = O.required "comment_url"
             })

----------------------------
-- Unread items
$(makeAdaptorAndInstance "pUnreadItem" ''UnreadItem)

type UnreadItemW = UnreadItem FeedItemIdColumnW UserIdColumnW

type UnreadItemR = UnreadItem FeedItemIdColumnR UserIdColumnR

unreadItemTable :: O.Table UnreadItemW UnreadItemR
unreadItemTable =
    O.Table
        "unread_item"
        (pUnreadItem
             UnreadItem
             { unreadFeedItemId = pFeedItemId (FeedItemId (O.required "feed_item_id"))
             , unreadUserId = pUserId (UserId (O.required "user_id"))
             })

$(makeAdaptorAndInstance "pAuthToken" ''AuthToken)

type AuthTokenW = AuthToken UserIdColumnW (O.Column O.PGText)

type AuthTokenR = AuthToken UserIdColumnR (O.Column O.PGText)

authTokenTable :: O.Table AuthTokenW AuthTokenR
authTokenTable =
    O.Table
        "auth_token"
        (pAuthToken
             AuthToken
             { authTokenHeedUserId = pUserId (UserId (O.required "user_id"))
             , authTokenToken = O.required "token"
             })

$(makeAdaptorAndInstance "pFeFeedInfo" ''FeFeedInfo')

type FeFeedInfoR = FeFeedInfo' (O.Column O.PGInt4) (O.Column O.PGText) (O.Column O.PGInt8)

$(makeAdaptorAndInstance "pFeItemInfo" ''FeItemInfo')

type FeItemInfoR = FeItemInfo' (O.Column O.PGInt4) (O.Column O.PGText) (O.Column O.PGText) (O.Column O.PGTimestamptz) (O.Column (O.Nullable O.PGText)) (O.Column O.PGBool)

instance O.QueryRunnerColumnDefault O.PGBool Seen where
    queryRunnerColumnDefault = fromBool <$> O.fieldQueryRunnerColumn
