{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeSynonymInstances #-}

module Heed.Database where

import Data.Aeson
import Data.Text (Text)
import Data.Time.Clock (UTCTime(..))
import GHC.Generics

-- * Define database types, the actual types that 'Opaleye' uses is in 'Heed.DbTypes'
-- which won't be included when compiling with ghcjs since 'postgresql-simple'
-- doesn't compile with ghjs
-- Type name guide:
-- W = Write
-- R = Read
-- H = Haskell world
-- WO = Write Optional
-- Users Table

type Url = Text

-- | PostgreSQL User Table
data User a b c d = User
    { userId :: a -- ^ PGInt4
    , userName :: b -- ^ Text
    , userPassword :: c -- ^ Bytestring
    , userEmail :: c -- ^ Text
    }

-- | For additional typesafety
newtype UserId a = UserId
    { getUserId :: a
    } deriving (Functor)

-- | User in Haskell Land
type UserH = User (UserId Int) Text Text Text

-- | PostgreSQL Feeds Table
data FeedInfo a b c d e = FeedInfo
    { feedInfoId :: a -- ^ Autogenerated PGInt4
    , feedInfoName :: b -- ^ Feed Name
    , feedInfoUrl :: c -- ^ Feed url
    , feedInfoUpdateEvery :: d -- ^ Update every minutes
    , feedInfoLastUpdated :: e -- ^ Last time the feed was downloaded and items
                               --   added to the db
    } deriving (Show, Generic)

-- | For additional typesafety
newtype FeedInfoId a = FeedInfoId
    { getFeedInfoId :: a
    } deriving (Functor, Show, Generic)

instance FromJSON FeedInfoIdH

instance ToJSON FeedInfoIdH

-- | 'FeedInfoId' Haskell
type FeedInfoIdH = FeedInfoId Int

-- | 'FeedInfo' Haskell read from DB
type FeedInfoHR = FeedInfo (FeedInfoId Int) Text Text Int UTCTime

-- | 'FeedInfo' Haskell write to DB (Id is missing)
type FeedInfoHW = FeedInfo (FeedInfoId (Maybe Int)) Text Text Int UTCTime

instance FromJSON FeedInfoHR

instance ToJSON FeedInfoHR

-- | PostgreSQL Feeds <-> Users (Subscriptions) Table
data Subscription a b = Subscription
    { subscriptionFeedId :: a -- ^ Foreign key on FeedInfoId
    , subscriptionUserId :: b -- ^ Foreign key on UserId
    }

-- | PostgreSQL Feed items Table
data FeedItem a b c d e f = FeedItem
    { feedItemId :: a -- ^ Autogenerated PGInt4
    , feedItemFeedId :: b -- ^ Foreign Key to FeedInfoId PGInt4
    , feedItemTitle :: c -- ^ Item title Text
    , feedItemUrl :: d -- ^ Item url Url
    , feedItemDate :: e -- ^ Item date
    , feedItemComments :: f -- ^ Comment url if available (ala HN)
    }

-- | For additional typesafety
newtype FeedItemId a = FeedItemId
    { getFeedItemId :: a
    } deriving (Functor, Show, Generic)

-- | FeedItemId Haskell
type FeedItemIdH = FeedItemId Int

instance ToJSON FeedItemIdH

instance FromJSON FeedItemIdH

-- | 'FeedItem' Haskell read from DB
type FeedItemHR = FeedItem (FeedItemId Int) (FeedInfoId Int) Text Url UTCTime (Maybe Url)

-- | 'FeedItem' Haskell write to DB (ItemId is missing)
type FeedItemHW = FeedItem (FeedItemId (Maybe Int)) (FeedInfoId (Maybe Int)) Text Url UTCTime (Maybe Url)

-- | Unread items
data UnreadItem a b = UnreadItem
    { unreadFeedItemId :: a -- ^ Foreign key on FeedItemId -- PGInt4
    , unreadUserId :: b -- ^ Foreign key on UserId -- PGInt4
    }

-- | PostgreSQL Authentication token table
data AuthToken a b = AuthToken
    { authTokenHeedUserId :: a -- ^ Foreign key on UserId -- PGInt4
    , authTokenToken :: b -- ^ Randomly generated token -- Text
    }
